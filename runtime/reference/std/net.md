---
title: "@std/net"
description: "Utilities for working with the network"
jsr: jsr:@std/net
pkg: net
version: 1.0.6
generated: true
stability: stable
---

<!-- Autogenerated from JSR docs. Do not edit directly. -->

## Overview

<p>Network utilities.</p>

```js
import { getAvailablePort } from "@std/net";

const command = new Deno.Command(Deno.execPath(), {
  args: ["test.ts", "--port", getAvailablePort().toString()],
});

// ...
```

### Add to your project

```sh
deno add jsr:@std/net
```

<a href="https://jsr.io/@std/net/doc" class="docs-cta jsr-cta">See all symbols
in @std/net on
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->

## What is @std/net?

Utilities to help with common networking tasks that complement Deno's core APIs:

- Finding or reserving an open port.
- Discovering a machine's LAN address to bind servers.
- Validating IP versions and checking if an address belongs to a CIDR subnet.

## Why use @std/net?

- To pick safe ports and interfaces:
  - Prefer ephemeral ports via `Deno.listen({ port: 0 })` when you control the
    listener.
  - Use `getAvailablePort()` when you need a free port value to pass to other
    processes before binding (then bind immediately to avoid races).
- Bind to the right network: use `getNetworkAddress()` to serve on your LANâ€™s
  IPv4 or IPv6 address instead of loopback.
- Validate and filter traffic: `isIPv4`/`isIPv6` and `match*Subnet` helpers let
  you build allow/deny lists or feature gates by IP ranges.

## Examples

```ts
const listener = Deno.listen({ hostname: "127.0.0.1", port: 0 });
const { port } = listener.addr as Deno.NetAddr;
// start server on listener ...
```

### Bind to a LAN address (not just localhost)

```ts
import { getNetworkAddress } from "@std/net/unstable-get-network-address";

const hostname = getNetworkAddress() ?? "127.0.0.1"; // default IPv4
Deno.serve({ hostname, port: 0 }, () => new Response("Hello from LAN"));
```

### Validate incoming IP family

```ts
import { isIPv4, isIPv6 } from "@std/net/unstable-ip";

function describe(ip: string): string {
  if (isIPv4(ip)) return "IPv4";
  if (isIPv6(ip)) return "IPv6";
  return "unknown";
}
```

### Allowlist requests by subnet (IPv4 and IPv6)

```ts
import { matchSubnets } from "@std/net/unstable-ip";

const allowlist = [
  "192.168.1.0/24", // home LAN
  "2001:db8::/64", // docs example IPv6 prefix
];

Deno.serve((req, info) => {
  const ip = (info.remoteAddr as Deno.NetAddr).hostname;
  if (!matchSubnets(ip, allowlist)) {
    return new Response("Forbidden", { status: 403 });
  }
  return new Response("OK");
});
```

### Pass a free port to a child process

```ts
import { getAvailablePort } from "@std/net";

const port = getAvailablePort();
// Immediately reserve it in your process if possible to avoid races
const listener = Deno.listen({ hostname: "127.0.0.1", port });

const child = new Deno.Command("deno", {
  args: ["run", "--allow-net", "./child_server.ts", String(port)],
});
child.spawn();
```

## Tips

- Prefer `Deno.listen({ port: 0 })` when possible; use `getAvailablePort()` only
  when you must pass a port value to another process first.
- After obtaining a port number, bind right away in the same process to avoid
  TOCTOU race conditions.
- `unstable-ip` helpers are great for allow/deny lists but avoid putting full
  access control solely in client-controlled headers like `X-Forwarded-For`.

<!-- custom:end -->
