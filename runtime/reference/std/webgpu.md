---
title: "@std/webgpu"
description: "Utilities for working with the Web GPU API"
jsr: jsr:@std/webgpu
pkg: webgpu
version: 0.224.9
generated: true
stability: unstable
---
<!-- Autogenerated from JSR docs. Do not edit directly. -->

:::info Unstable

This @std package is experimental and its API may change without a major version bump.

:::
## Overview

<p>Utilities for interacting with the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API" rel="nofollow">WebGPU API</a>.</p>

```js
import { createTextureWithData } from "@std/webgpu";

const adapter = await navigator.gpu.requestAdapter();
const device = await adapter?.requestDevice()!;

createTextureWithData(device, {
  format: "bgra8unorm-srgb",
  size: {
    width: 3,
    height: 2,
  },
  usage: GPUTextureUsage.COPY_SRC,
}, new Uint8Array([1, 1, 1, 1, 1, 1, 1]));
```

### Add to your project

```sh
deno add jsr:@std/webgpu
```

<a href="https://jsr.io/@std/webgpu/doc" class="docs-cta jsr-cta">See all symbols in @std/webgpu on
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->
## What is the WebGPU API?

WebGPU is a modern graphics API that provides high-performance 3D graphics and
computation capabilities in web applications. It is designed to be a successor
to WebGL, offering lower-level access to GPU hardware and improved performance
for complex graphics and compute tasks.

## Why use @std/webgpu?

Use for common WebGPU patterns and utilities to simplify setup and resource
management:

- Request the adapter/device once and reuse; feature/limit negotiation up front
  avoids runtime failures.
- Set texture `usage` bits to match all intended operations (COPY_SRC, COPY_DST,
  TEXTURE_BINDING, RENDER_ATTACHMENT).
- Prefer `device.queue.writeBuffer`/`writeTexture` for small uploads; use
  staging buffers for large transfers.

## Examples

### Writing to a buffer

```ts
const buf = device.createBuffer({
  size: 16,
  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,
});
device.queue.writeBuffer(buf, 0, new Uint32Array([1, 2, 3, 4]));
```

### Describe a texture format

```ts
import { describeTextureFormat } from "@std/webgpu";

const info = describeTextureFormat("rgba8unorm");
console.log(info.sampleType); // e.g. "float"
console.log(info.allowedUsages.includes(GPUTextureUsage.RENDER_ATTACHMENT));
console.log(info.blockSize, info.blockDimensions); // bytes per block and block size
```

### Copy a texture to a buffer (with padding)

```ts
import {
  describeTextureFormat,
  getRowPadding,
  resliceBufferWithPadding,
} from "@std/webgpu";

const format: GPUTextureFormat = "rgba8unorm";
const size = { width: 320, height: 200 };
const tex = device.createTexture({
  format,
  size,
  usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
});

// Compute bytesPerRow with required alignment for buffer copies
const { blockSize, blockDimensions } = describeTextureFormat(format);
const bytesPerPixel = blockSize /
  (blockDimensions.width * blockDimensions.height);
const { padded: bytesPerRow } = getRowPadding(size.width * bytesPerPixel);
const bufferSize = bytesPerRow * size.height;

const out = device.createBuffer({
  size: bufferSize,
  usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
});

const encoder = device.createCommandEncoder();
encoder.copyTextureToBuffer(
  { texture: tex },
  { buffer: out, bytesPerRow, rowsPerImage: size.height },
  size,
);
device.queue.submit([encoder.finish()]);

await out.mapAsync(GPUMapMode.READ);
const padded = out.getMappedRange();
const pixels = resliceBufferWithPadding(
  new Uint8Array(padded),
  bytesPerRow,
  size,
);
// `pixels` is tightly packed RGBA rows, suitable for encoding/saving
```

### Capture a render target into a buffer

```ts
import { createCapture } from "@std/webgpu";

const { texture, outputBuffer } = createCapture(device, {
  size: { width: 256, height: 256 },
  format: "rgba8unorm",
});

// draw to `texture` as a color attachment, then copy it into `outputBuffer` internally
// later map the buffer to read pixels
await outputBuffer.mapAsync(GPUMapMode.READ);
const data = new Uint8Array(outputBuffer.getMappedRange());
// use `data`...
```

## Tips

- Check for WebGPU support with `if (!navigator.gpu) { ... }`.
- Request the adapter/device once and reuse; feature/limit negotiation up front
  avoids runtime failures.
- Set texture `usage` bits to match all intended operations (COPY_SRC, COPY_DST,
  TEXTURE_BINDING, RENDER_ATTACHMENT).
<!-- custom:end -->
