---
title: "@std/cbor"
description: "Utilities for parsing and serializing Concise Binary Object Representation (CBOR)"
jsr: jsr:@std/cbor
pkg: cbor
version: 0.1.8
generated: true
stability: unstable
---
<!-- Autogenerated from JSR docs. Do not edit directly. -->

:::info Unstable

This @std package is experimental and its API may change without a major version bump.

:::
## Overview

<h2 id="overview">
Overview</h2>
<p>Concise Binary Object Representation (CBOR) is a binary data serialisation
format optimised for compactness and efficiency. It is designed to encode a
wide range of data types, including integers, strings, arrays, and maps, in a
space-efficient manner.
<a href="https://datatracker.ietf.org/doc/html/rfc8949" rel="nofollow">RFC 8949 - Concise Binary Object Representation (CBOR)</a>
spec.</p>
<h2 id="limitations">
Limitations</h2>
<ul>
<li>This implementation only supports the encoding and decoding of
"Text String" keys.</li>
<li>This implementation encodes decimal numbers with 64 bits. It takes no
effort to figure out if the decimal can be encoded with 32 or 16 bits.</li>
<li>When decoding, integers with a value below 2 ** 32 will be of type
<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number" rel="nofollow">number</a>, with all larger integers being of type <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/BigInt" rel="nofollow">bigint</a>.</li>
</ul>
<p>Functions and classes may have more specific limitations listed.</p>

```js
import { assert, assertEquals } from "@std/assert";
import { decodeCbor, encodeCbor } from "@std/cbor";

const rawMessage = "I am a raw Message!";

const encodedMessage = encodeCbor(rawMessage);
const decodedMessage = decodeCbor(encodedMessage);

assert(typeof decodedMessage === "string");
assertEquals(decodedMessage, rawMessage);
```

### Add to your project

```sh
deno add jsr:@std/cbor
```

<a href="https://jsr.io/@std/cbor/doc" class="docs-cta jsr-cta">See all symbols in @std/cbor on
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->
## What is CBOR?

CBOR (Concise Binary Object Representation) is like a binary version of JSON. It
stores data in a compact binary format instead of text, which reduces size and
speeds up parsing.

It supports all the common types (numbers, strings, booleans, null, arrays,
maps) plus binary data and big integers. CBOR is typically used for sending data
over the network (ideal for IoT or mobile devices where there is limited
bandwidth), storing compact payloads, and interop between languages.

## Why use @std/cbor?

This package provides simple functions to encode JavaScript objects to CBOR
binary and decode CBOR binary back to JavaScript objects.

## Examples

```ts
import { decodeCbor, encodeCbor } from "@std/cbor";

const obj = { t: "temp", v: 21.5, ts: Date.now() };
const bin = encodeCbor(obj);
const back = decodeCbor(bin);
```

### Binary data (Uint8Array)

```ts
import { decodeCbor, encodeCbor } from "@std/cbor";

const bytes = new TextEncoder().encode("hello");
const encoded = encodeCbor(bytes);
const decoded = decodeCbor(encoded);

if (!(decoded instanceof Uint8Array)) throw new Error("expected bytes");
console.log(new TextDecoder().decode(decoded)); // "hello"
```

### Big integers behavior

Integers larger than 2**32 decode as bigint:

```ts
import { decodeCbor, encodeCbor } from "@std/cbor";

const bigNumber = 5_000_000_000; // > 2**32
const bigBytes = encodeCbor(bigNumber);
const bigValue = decodeCbor(bigBytes);

console.log(typeof bigValue); // "bigint"
console.log(bigValue === 5_000_000_000n); // true

const smallValue = decodeCbor(encodeCbor(42));
console.log(typeof smallValue); // "number"
```

### Sequences (multiple values)

```ts
import { decodeCborSequence, encodeCborSequence } from "@std/cbor";

const packet = encodeCborSequence([{ id: 1 }, { id: 2 }, "done" as const]);
const values = decodeCborSequence(packet);
// values: [{ id: 1 }, { id: 2 }, "done"]
```

### Tagged values (dates)

Use CBOR Tag 1 for epoch-based time (seconds since Unix epoch). How you
interpret tags on decode is up to your app.

```ts
import { decodeCbor, encodeCbor } from "@std/cbor";
import { CborTag } from "@std/cbor/tag";

const nowSeconds = Math.floor(Date.now() / 1000);
const tagged = new CborTag(1, nowSeconds);
const buf = encodeCbor(tagged);

const out = decodeCbor(buf) as CborTag;
console.log(out.tagNumber); // 1
console.log(out.tagContent); // epoch seconds
```

### Decode guard pattern

When consuming untrusted bytes, check shapes after decode.

```ts
import { decodeCbor } from "@std/cbor";

function isRecord(x: unknown): x is Record<string, unknown> {
  return typeof x === "object" && x !== null && !Array.isArray(x);
}

const bytesFromNetwork = new Uint8Array(/* ... */);
const value = decodeCbor(bytesFromNetwork);

if (!isRecord(value) || typeof value.type !== "string") {
  throw new Error("Unexpected payload");
}

// safe to use
console.log(value.type);
```
<!-- custom:end -->
