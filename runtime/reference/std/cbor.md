---
title: "@std/cbor"
description: "Utilities for parsing and serializing Concise Binary Object Representation (CBOR)"
jsr: jsr:@std/cbor
pkg: cbor
version: 0.1.8
generated: true
stability: unstable
---
<!-- Autogenerated from JSR docs. Do not edit directly. -->

> ⚠️ **Unstable**: This @std package is experimental and its API may change without a major version bump.

## Overview

<h2 id="overview">
Overview</h2>
<p>Concise Binary Object Representation (CBOR) is a binary data serialisation
format optimised for compactness and efficiency. It is designed to encode a
wide range of data types, including integers, strings, arrays, and maps, in a
space-efficient manner.
<a href="https://datatracker.ietf.org/doc/html/rfc8949" rel="nofollow">RFC 8949 - Concise Binary Object Representation (CBOR)</a>
spec.</p>
<h2 id="limitations">
Limitations</h2>
<ul>
<li>This implementation only supports the encoding and decoding of
"Text String" keys.</li>
<li>This implementation encodes decimal numbers with 64 bits. It takes no
effort to figure out if the decimal can be encoded with 32 or 16 bits.</li>
<li>When decoding, integers with a value below 2 ** 32 will be of type
<a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number" rel="nofollow">number</a>, with all larger integers being of type <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/BigInt" rel="nofollow">bigint</a>.</li>
</ul>
<p>Functions and classes may have more specific limitations listed.</p>
<pre class="highlight"><code><span class="pl-k">import</span> { assert, assertEquals } <span class="pl-k">from</span> <span class="pl-s">"@std/assert"</span>;
<span class="pl-k">import</span> { decodeCbor, encodeCbor } <span class="pl-k">from</span> <span class="pl-s">"@std/cbor"</span>;

<span class="pl-k">const</span> rawMessage <span class="pl-c1">=</span> <span class="pl-s">"I am a raw Message!"</span>;

<span class="pl-k">const</span> encodedMessage <span class="pl-c1">=</span> <span class="pl-en">encodeCbor</span>(rawMessage);
<span class="pl-k">const</span> decodedMessage <span class="pl-c1">=</span> <span class="pl-en">decodeCbor</span>(encodedMessage);

<span class="pl-en">assert</span>(<span class="pl-k">typeof</span> decodedMessage <span class="pl-c1">===</span> <span class="pl-s">"string"</span>);
<span class="pl-en">assertEquals</span>(decodedMessage, rawMessage);
</code><button class="copyButton" data-copy="import { assert, assertEquals } from &quot;@std/assert&quot;;
import { decodeCbor, encodeCbor } from &quot;@std/cbor&quot;;

const rawMessage = &quot;I am a raw Message!&quot;;

const encodedMessage = encodeCbor(rawMessage);
const decodedMessage = decodeCbor(encodedMessage);

assert(typeof decodedMessage === &quot;string&quot;);
assertEquals(decodedMessage, rawMessage);
"><svg class="copy" width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect x="2" y="2" width="7" height="7" fill="none"></rect>
  <rect x="6" y="6" width="7" height="7" fill="none"></rect>
  <path d="M1.55566 2.7C1.55566 2.03726 2.09292 1.5 2.75566 1.5H8.75566C9.41841 1.5 9.95566 2.03726 9.95566 2.7V5.1H12.3557C13.0184 5.1 13.5557 5.63726 13.5557 6.3V12.3C13.5557 12.9627 13.0184 13.5 12.3557 13.5H6.35566C5.69292 13.5 5.15566 12.9627 5.15566 12.3V9.9H2.75566C2.09292 9.9 1.55566 9.36274 1.55566 8.7V2.7ZM6.35566 9.9V12.3H12.3557V6.3H9.95566V8.7C9.95566 9.36274 9.41841 9.9 8.75566 9.9H6.35566ZM8.75566 8.7V2.7H2.75566V8.7H8.75566Z" fill="currentColor"></path>
</svg>
<svg class="check" width="15" height="15" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round" xmlns="http://www.w3.org/2000/svg">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
  <path d="M5 12l5 5l10 -10"></path>
</svg>
</button><code></code></pre>

<!-- custom:start -->
<!-- Add persistent custom content below. This section is preserved across generations. -->

<!-- custom:end -->
