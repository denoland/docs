---
title: "@std/async"
description: "Utilities for asynchronous operations, like delays, debouncing, or pooling"
jsr: jsr:@std/async
pkg: async
version: 1.0.15
generated: true
stability: stable
---
<!-- Autogenerated from JSR docs. Do not edit directly. -->

## Overview

<p>Provide helpers with asynchronous tasks like <a href="https://jsr.io/@std/async@1.0.15/doc/~/delay" rel="nofollow"><code>delays</code></a>,
<a href="https://jsr.io/@std/async@1.0.15/doc/~/debounce" rel="nofollow"><code>debouncing</code></a>, <a href="https://jsr.io/@std/async@1.0.15/doc/~/retry" rel="nofollow"><code>retrying</code></a>, or
<a href="https://jsr.io/@std/async@1.0.15/doc/~/pooledMap" rel="nofollow"><code>pooling</code></a>.</p>

```js
import { delay } from "@std/async/delay";

await delay(100); // waits for 100 milliseconds
```
### Add to your project

```sh
deno add jsr:@std/async
```

<a href="https://jsr.io/@std/async/docs" class="docs-cta jsr-cta">See all symbols in @std/async on
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->
## What is async?

Asynchronous programming lets your program start work now and finish it later
without blocking the main thread. In JavaScript this typically means Promises,
`async`/`await`, timers, and async iterables. Async code improves responsiveness
and throughput by overlapping I/O (network, disk, timers) and controlling
concurrency.

## Why use @std/async?

This package gives you small, focused utilities that solve common async problems
so you don’t have to re‑implement them:

- `delay` and `deadline` for scheduling and timeouts (with cancellation via
  `AbortSignal`).
- `debounce` (and `throttle` in unstable) to control call frequency for UI/CLI
  events.
- `retry` with backoff/jitter for flaky operations like HTTP requests.
- `pooledMap` to cap concurrency when transforming streams of work.
- `tee`/`MuxAsyncIterator` to branch or merge async iterables.

These helpers are tiny, predictable, and work across Deno, Node.js, Bun,
Workers, and the browser.

## Examples

Debounce rapid events (e.g., typeahead):

```ts
import { debounce } from "@std/async/debounce";

const search = debounce(async (q: string) => {
  // fetch results after the user pauses typing
}, 200);

// call many times; only the last call after 200ms runs
search("d");
search("de");
search("deno");
```

Retry with exponential backoff and jitter:

```ts
import { retry } from "@std/async/retry";

const data = await retry(() =>
  fetch("/api").then((r) => {
    if (!r.ok) throw new Error("bad status");
    return r.json();
  }), {
  maxAttempts: 5,
  minTimeout: 100,
  multiplier: 2,
  jitter: 0.2,
});
```

Limit concurrency with pooledMap:

```ts
import { pooledMap } from "@std/async/pool";

const urls = ["/a", "/b", "/c", "/d"]; // many more in practice
for await (const res of pooledMap(3, urls, (u) => fetch(u))) {
  // at most 3 fetches in flight; results arrive as they complete
}
```

Deadlines and cancellation:

```ts
import { deadline } from "@std/async/deadline";

await deadline(fetch("/slow"), 1_000); // throws DOMException("TimeoutError") after 1s
```
<!-- custom:end -->
