---
title: "@std/msgpack"
description: "Encoding and decoding for the msgpack format"
jsr: jsr:@std/msgpack
pkg: msgpack
version: 1.0.3
generated: true
stability: stable
---
<!-- Autogenerated from JSR docs. Do not edit directly. -->

## Overview

<p>This module provides functions to encode and decode MessagePack.</p>
<p>MessagePack is an efficient binary serialization format that is language
agnostic. It is like JSON, but generally produces much smaller payloads.
<a href="https://msgpack.org/" rel="nofollow">Learn more about MessagePack</a>.</p>

```js
import { decode, encode } from "@std/msgpack";
import { assertEquals } from "@std/assert";

const obj = {
  str: "deno",
  arr: [1, 2, 3],
  bool: true,
  nil: null,
  map: {
    foo: "bar"
  }
};

const encoded = encode(obj);
assertEquals(encoded.length, 42);

const decoded = decode(encoded);
assertEquals(decoded, obj);
```

<p>MessagePack supports encoding and decoding the following types:</p>
<ul>
<li><code>number</code></li>
<li><code>bigint</code></li>
<li><code>string</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>Uint8Array</code></li>
<li>arrays of values of these types</li>
<li>objects with string or number keys, and values of these types</li>
</ul>

### Add to your project

```sh
deno add jsr:@std/msgpack
```

<a href="https://jsr.io/@std/msgpack/doc" class="docs-cta jsr-cta">See all symbols in @std/msgpack on
<svg class="inline ml-1" viewBox="0 0 13 7" aria-hidden="true" height="20"><path d="M0,2h2v-2h7v1h4v4h-2v2h-7v-1h-4" fill="#083344"></path><g fill="#f7df1e"><path d="M1,3h1v1h1v-3h1v4h-3"></path><path d="M5,1h3v1h-2v1h2v3h-3v-1h2v-1h-2"></path><path d="M9,2h3v2h-1v-1h-1v3h-1"></path></g></svg></a>

<!-- custom:start -->
## What is MessagePack?

MessagePack is a binary serialization format that is compact, fast, and
schema-less. It is designed to be efficient in both size and speed, making it
suitable for high-performance applications and data exchange between different
programming languages.

## Why use @std/msgpack?

- MessagePack is great for compact, fast, schema-less payloads between trusted
  services. Useful if you need a more efficient alternative to JSON.
- Binary-safe: `Uint8Array` round-trips without base64 overhead.

## Examples

```ts
import { decode, encode } from "@std/msgpack";

const payload = { id: 1, items: ["a", "b"], data: new Uint8Array([1, 2, 3]) };
const bin = encode(payload);
const back = decode(bin);
```

Custom extension types

```ts
import { Decoder, Encoder, ExtData } from "@std/msgpack";

// tag 1 for Date
const enc = new Encoder({
  extensionCodec: {
    tryToEncode(object) {
      if (object instanceof Date) {
        return new ExtData(
          1,
          new Uint8Array(new BigInt64Array([BigInt(object.getTime())]).buffer),
        );
      }
    },
  },
});

const dec = new Decoder({
  extensionCodec: {
    decode(data) {
      if (data.type === 1) {
        return new Date(Number(new BigInt64Array(data.data.buffer)[0]));
      }
    },
  },
});
```

## Tips

- Beware of bigint vs number: very large integers decode to `bigint`.
- For interop with other languages, stick to common types (number, string,
  boolean, null, arrays, maps, bytes).
<!-- custom:end -->
