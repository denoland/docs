#!/usr/bin/env -S deno run --allow-read --allow-write
/**
 * Enhanced Orama Index Generator for Deno Documentation
 *
 * This script generates a comprehensive JSON file containing all documentation content,
 * including both markdown files and API reference documentation generated by reference_gen.
 *
 * It processes:
 * - Markdown documentation from runtime/, deploy/, examples/, etc.
 * - API reference documentation from reference_gen/gen/ (Deno, Web, Node APIs)
 *
 * Usage:
 *   deno task generate:orama:full          # Generate comprehensive index
 *   deno run -A generate_orama_index_full.ts _site  # Generate to _site directory
 */

import { walk } from "@std/fs";
import { fromFileUrl, join, relative } from "@std/path";

const BASE_URL = "https://docs.deno.com";
const ROOT_DIR = fromFileUrl(new URL("../", import.meta.url));

// Directories to include for markdown documentation
const INCLUDE_DIRS = [
  "runtime",
  "deploy",
  "examples",
  "subhosting",
  "lint",
];

// Reference documentation files
const REFERENCE_FILES = [
  {
    path: "reference_gen/gen/deno.json",
    apiType: "deno",
    baseUrl: "/api/deno",
  },
  { path: "reference_gen/gen/web.json", apiType: "web", baseUrl: "/api/web" },
  {
    path: "reference_gen/gen/node.json",
    apiType: "node",
    baseUrl: "/api/node",
  },
];

// Files to exclude (relative paths)
const EXCLUDE_FILES = [
  "README.md",
  "deno.json",
  "deno.lock",
  "lume.ts",
  "server.ts",
];

// Extensions to include
const INCLUDE_EXTS = [".md", ".mdx"];

// Regex patterns for content extraction
const H1_REGEX = /^# (.+)$/m;
const FRONTMATTER_TITLE_REGEX = /title: ["'](.+)["']/;
const DESCRIPTION_REGEX = /description: ["'](.+)["']/;
const TAGS_REGEX = /tags: \[(.*?)\]/;

interface OramaDocument {
  id: string;
  title: string;
  content: string;
  url: string;
  category: string;
  section: string;
  subsection?: string;
  description?: string;
  tags: string[];
  headings: string[];
  lastModified: number;
  docType: "markdown" | "api-reference";
  apiInfo?: {
    symbolType: string; // "function", "interface", "class", etc.
    symbolPath: string; // "Deno.readFile", "web.fetch", etc.
    packageName: string; // "Deno", "Web", "Node"
  };
}

interface IndexStats {
  totalDocuments: number;
  totalCharacters: number;
  averageDocumentLength: number;
  categoryCounts: Record<string, number>;
  sectionCounts: Record<string, number>;
  documentsWithTags: number;
  documentsWithDescriptions: number;
  longestDocument: string;
  shortestDocument: string;
  apiDocuments: number;
  markdownDocuments: number;
}

/**
 * Clean markdown content by removing certain elements that aren't useful for search
 */
function cleanMarkdownContent(content: string): string {
  return content
  // Remove entire navigation blocks first
  .replace(/<nav\b[^>]*>[\s\S]*?<\/nav>/gi, "")
  // Remove any element marked as role="navigation"
  .replace(/<([a-zA-Z][\w:-]*)[^>]*\brole=["']navigation["'][^>]*>[\s\S]*?<\/\1>/gi, "")
    // Remove frontmatter
    .replace(/^---\n[\s\S]*?\n---\n/, "")
    // Remove code blocks (keep inline code)
    .replace(/```[\s\S]*?```/g, "")
    // Remove HTML comments
    .replace(/<!--[\s\S]*?-->/g, "")
    // Remove JSX/MDX components (basic cleanup)
    .replace(/<[^>]*>/g, "")
    // Remove image references
    .replace(/!\[.*?\]\(.*?\)/g, "")
    // Remove links but keep text
    .replace(/\[([^\]]+)\]\([^)]+\)/g, "$1")
    // Clean up multiple newlines
    .replace(/\n{3,}/g, "\n\n")
    // Remove excessive whitespace
    .replace(/[ \t]+/g, " ")
    .trim();
}

/**
 * Clean HTML content from API documentation
 */
function cleanHtmlContent(html: string): string {
  return html
  // Remove entire navigation blocks first
  .replace(/<nav\b[^>]*>[\s\S]*?<\/nav>/gi, " ")
  // Remove any element marked as role="navigation"
  .replace(/<([a-zA-Z][\w:-]*)[^>]*\brole=["']navigation["'][^>]*>[\s\S]*?<\/\1>/gi, " ")
    // Remove HTML tags but keep content
    .replace(/<[^>]*>/g, " ")
    // Remove code blocks and examples (they're often too verbose)
    .replace(/```[\s\S]*?```/g, "")
    // Remove excessive whitespace
    .replace(/\s+/g, " ")
    // Remove newlines
    .replace(/\n/g, " ")
    .trim();
}

/**
 * Extract headings from markdown content
 */
function extractHeadings(content: string): string[] {
  const headings: string[] = [];

  // Extract H1s
  const h1Matches = content.matchAll(/^# (.+)$/gm);
  for (const match of h1Matches) {
    headings.push(match[1].trim());
  }

  // Extract H2s
  const h2Matches = content.matchAll(/^## (.+)$/gm);
  for (const match of h2Matches) {
    headings.push(match[1].trim());
  }

  // Extract H3s
  const h3Matches = content.matchAll(/^### (.+)$/gm);
  for (const match of h3Matches) {
    headings.push(match[1].trim());
  }

  return headings;
}

/**
 * Extract tags from frontmatter
 */
function extractTags(frontmatter: string): string[] {
  const match = frontmatter.match(TAGS_REGEX);
  if (match) {
    return match[1]
      .split(",")
      .map((tag) => tag.trim().replace(/["']/g, ""))
      .filter((tag) => tag.length > 0);
  }
  return [];
}

/**
 * Determine category and section from file path
 */
function getCategoryAndSection(
  relativePath: string,
): { category: string; section: string; subsection: string | null } {
  const parts = relativePath.split("/");
  const category = parts[0] || "general";
  const section = parts[1] || "general";
  const subsection = parts.length > 2 ? parts[2] : null;

  return { category, section, subsection };
}

/**
 * Generate a unique ID for the document
 */
function generateId(relativePath: string, apiType?: string): string {
  const basePath = apiType ? `api-${apiType}-${relativePath}` : relativePath;
  return basePath
    .replace(/\.(md|mdx|json)$/, "")
    .replace(/[\/\\]/g, "-")
    .replace(/[^a-zA-Z0-9-_~.]/g, "")
    .toLowerCase();
}

/**
 * Build URL from relative path
 */
function buildUrl(relativePath: string, baseUrl?: string): string {
  if (baseUrl) {
    // For API docs, the URL structure is different
    return `${BASE_URL}${baseUrl}/${relativePath}`;
  }

  let url = relativePath.replace(/\.(md|mdx)$/, "");
  if (url.endsWith("/index")) {
    url = url.replace(/\/index$/, "/");
  }
  if (!url.startsWith("/")) {
    url = "/" + url;
  }
  return `${BASE_URL}${url}`;
}

/**
 * Build path from relative path (without base URL)
 */
function buildPath(relativePath: string, baseUrl?: string): string {
  if (baseUrl) {
    // For API docs, return relative path with baseUrl
    return `${baseUrl}/${relativePath}`;
  }

  let path = relativePath.replace(/\.(md|mdx)$/, "");
  if (path.endsWith("/index")) {
    path = path.replace(/\/index$/, "/");
  }
  if (!path.startsWith("/")) {
    path = "/" + path;
  }
  return path;
}

/**
 * Process a single API symbol from reference documentation
 */
function processApiSymbol(
  symbolPath: string,
  symbolData: unknown,
  apiType: string,
  baseUrl: string,
  packageName: string,
): OramaDocument[] {
  try {
    // Type guard for symbolData
    if (!symbolData || typeof symbolData !== "object") {
      return [];
    }

    const data = symbolData as Record<string, unknown>;

    // Extract basic information
    const symbolGroupCtx = data.symbol_group_ctx as
      | Record<string, unknown>
      | undefined;
    const htmlHeadCtx = data.html_head_ctx as
      | Record<string, unknown>
      | undefined;
    const tocCtx = data.toc_ctx as
      | Record<string, unknown>
      | undefined;

    const symbolName = symbolGroupCtx?.name as string ||
      symbolPath.split(".").pop() || "Unknown";
    const title = htmlHeadCtx?.title as string || symbolName;

    // Extract content from various sources
    let content = "";

    // Get description from docs field if available
    const symbols = symbolGroupCtx?.symbols as unknown[] | undefined;
    if (symbols?.[0] && typeof symbols[0] === "object") {
      const firstSymbol = symbols[0] as Record<string, unknown>;
      const symbolContent = firstSymbol.content as unknown[] | undefined;
      if (symbolContent?.[0] && typeof symbolContent[0] === "object") {
        const contentValue = (symbolContent[0] as Record<string, unknown>)
          .value as Record<string, unknown> | undefined;
        if (contentValue?.docs && typeof contentValue.docs === "string") {
          content += cleanHtmlContent(contentValue.docs);
        }

        // Get content from sections
        const sections = contentValue?.sections as unknown[] | undefined;
        if (sections) {
          for (const section of sections) {
            if (section && typeof section === "object") {
              const sectionObj = section as Record<string, unknown>;
              const header = sectionObj.header as
                | Record<string, unknown>
                | undefined;
              if (header?.title && typeof header.title === "string") {
                content += ` ${header.title}`;
              }
              const sectionContent = sectionObj.content as
                | Record<string, unknown>
                | undefined;
              if (
                sectionContent?.content && Array.isArray(sectionContent.content)
              ) {
                for (const item of sectionContent.content) {
                  if (item && typeof item === "object") {
                    const itemObj = item as Record<string, unknown>;
                    if (itemObj.js_doc && typeof itemObj.js_doc === "string") {
                      content += ` ${cleanHtmlContent(itemObj.js_doc)}`;
                    }
                    if (
                      itemObj.content && typeof itemObj.content === "string"
                    ) {
                      content += ` ${cleanHtmlContent(itemObj.content)}`;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    // Skip if no meaningful content
    if (content.length < 20) {
      return [];
    }

    // Determine symbol type
    let symbolType = "unknown";
    if (symbols?.[0] && typeof symbols[0] === "object") {
      const firstSymbol = symbols[0] as Record<string, unknown>;
      const kind = firstSymbol.kind as Record<string, unknown> | undefined;
      if (kind?.kind && typeof kind.kind === "string") {
        symbolType = kind.kind.toLowerCase();
      }
    }

    // Extract tags
    const tags: string[] = [apiType, symbolType];
    if (symbols?.[0] && typeof symbols[0] === "object") {
      const firstSymbol = symbols[0] as Record<string, unknown>;
      const symbolTags = firstSymbol.tags as unknown[] | undefined;
      if (symbolTags) {
        for (const tag of symbolTags) {
          if (tag && typeof tag === "object") {
            const tagObj = tag as Record<string, unknown>;
            if (
              tagObj.kind && typeof tagObj.kind === "string" &&
              !tags.includes(tagObj.kind)
            ) {
              tags.push(tagObj.kind);
            }
          }
        }
      }
    }

    // Build clean URL - preserve the ~/ prefix for API paths
    const cleanPath = symbolPath.replace(/^\.\//, "").replace(/\.json$/, "");
    const url = buildUrl(cleanPath, baseUrl);
    const path = buildPath(cleanPath, baseUrl);

    const documents: OramaDocument[] = [];

    // Create main document for the symbol
    documents.push({
      id: generateId(cleanPath, apiType),
      title: title.replace(" - Deno documentation", ""),
      content: content.trim(),
      url,
      path,
      category: `api-${apiType}`,
      section: packageName.toLowerCase(),
      subsection: symbolType,
      description: `${symbolType} in the ${packageName} API`,
      tags,
      headings: [],
      lastModified: Date.now(),
      docType: "api-reference",
      apiInfo: {
        symbolType,
        symbolPath: symbolName,
        packageName,
      },
    });

    // Process TOC entries to create anchor documents
    const documentNavigation = tocCtx?.document_navigation as unknown[] | undefined;
    if (documentNavigation && Array.isArray(documentNavigation)) {
      for (const navItem of documentNavigation) {
        if (navItem && typeof navItem === "object") {
          const navObj = navItem as Record<string, unknown>;
          const anchor = navObj.anchor as string | undefined;
          const navContent = navObj.content as string | undefined;
          
          if (anchor && navContent) {
            // Create a document for this anchor
            documents.push({
              id: generateId(`${cleanPath}-${anchor}`, apiType),
              title: `${symbolName}.${navContent}`,
              content: `${navContent} ${content.trim()}`,
              url: `${url}#${anchor}`,
              path: `${path}#${anchor}`,
              category: `api-${apiType}`,
              section: packageName.toLowerCase(),
              subsection: symbolType,
              description: `${navContent} - ${symbolType} in the ${packageName} API`,
              tags: [...tags, "anchor"],
              headings: [navContent],
              lastModified: Date.now(),
              docType: "api-reference",
              apiInfo: {
                symbolType,
                symbolPath: symbolName,
                packageName,
              },
            });
          }
        }
      }
    }

    return documents;
  } catch (error) {
    console.error(`Error processing API symbol ${symbolPath}:`, error);
    return [];
  }
}

/**
 * Process reference documentation from generated JSON files
 */
async function processReferenceDocumentation(): Promise<OramaDocument[]> {
  const documents: OramaDocument[] = [];

  for (const refFile of REFERENCE_FILES) {
    const filePath = join(ROOT_DIR, refFile.path);

    try {
      console.log(`Processing ${refFile.apiType} API documentation...`);

      const content = await Deno.readTextFile(filePath);
      const referenceData = JSON.parse(content);

      let processed = 0;
      let skipped = 0;

      // Process each symbol in the reference data
      for (const [symbolPath, symbolData] of Object.entries(referenceData)) {
        // Type guard and skip search pages and redirects
        if (!symbolData || typeof symbolData !== "object") {
          skipped++;
          continue;
        }

        const data = symbolData as Record<string, unknown>;
        if (data.kind === "search" || "path" in data) {
          skipped++;
          continue;
        }

        const docs = processApiSymbol(
          symbolPath,
          symbolData,
          refFile.apiType,
          refFile.baseUrl,
          refFile.apiType.charAt(0).toUpperCase() + refFile.apiType.slice(1),
        );

        if (docs && docs.length > 0) {
          documents.push(...docs);
          processed += docs.length;
        } else {
          skipped++;
        }
      }

      console.log(
        `  Processed ${processed} ${refFile.apiType} API symbols (skipped ${skipped})`,
      );
    } catch (error) {
      console.error(`Error processing ${refFile.path}:`, error);
    }
  }

  return documents;
}

/**
 * Collect and process markdown documentation files
 */
async function collectMarkdownFiles(): Promise<OramaDocument[]> {
  const files: OramaDocument[] = [];

  console.log("Scanning markdown directories:", INCLUDE_DIRS.join(", "));

  for (const dir of INCLUDE_DIRS) {
    const dirPath = join(ROOT_DIR, dir);

    try {
      for await (
        const entry of walk(dirPath, {
          includeDirs: false,
          includeFiles: true,
          exts: INCLUDE_EXTS,
        })
      ) {
        const relativePath = relative(ROOT_DIR, entry.path);

        // Skip excluded files
        if (EXCLUDE_FILES.some((exclude) => relativePath.includes(exclude))) {
          continue;
        }

        // Skip files in _* directories (components, etc.)
        if (relativePath.includes("/_")) {
          continue;
        }

        try {
          const content = await Deno.readTextFile(entry.path);
          const stat = await Deno.stat(entry.path);

          // Split frontmatter from content
          let markdownContent = content;
          const frontmatterMatch = content.match(
            /^---\n([\s\S]*?)\n---\n([\s\S]*)$/,
          );

          let frontmatter = "";
          if (frontmatterMatch) {
            frontmatter = frontmatterMatch[1];
            markdownContent = frontmatterMatch[2];
          }

          // Extract title from frontmatter or first h1
          let title = "";
          const titleMatch = frontmatter.match(FRONTMATTER_TITLE_REGEX);
          if (titleMatch) {
            title = titleMatch[1];
          } else {
            const h1Match = markdownContent.match(H1_REGEX);
            if (h1Match) {
              title = h1Match[1];
            } else {
              // Generate title from file path as fallback
              const pathParts = relativePath.replace(/\.(md|mdx)$/, "").split(
                "/",
              );
              title = pathParts[pathParts.length - 1]
                .replace(/[-_]/g, " ")
                .replace(/\b\w/g, (l) => l.toUpperCase());
            }
          }

          // Extract description
          let description = null;
          const descMatch = frontmatter.match(DESCRIPTION_REGEX);
          if (descMatch) {
            description = descMatch[1];
          }

          // Extract tags
          const tags = extractTags(frontmatter);

          // Extract headings
          const headings = extractHeadings(markdownContent);

          // Clean content for indexing
          const cleanedContent = cleanMarkdownContent(markdownContent);
          // Ensure title/description are part of searchable content
          const prefixParts: string[] = [];
          if (title) prefixParts.push(title);
          if (description) prefixParts.push(description);
          const prefixedContent = (prefixParts.join("\n\n") + "\n\n" + cleanedContent).trim();

          // Skip files with very little content
          if (prefixedContent.length < 50) {
            console.log(`Skipping ${relativePath} - content too short`);
            continue;
          }

          // Get category and section
          const { category, section, subsection } = getCategoryAndSection(
            relativePath,
          );

          // Build URL and path
          const url = buildUrl(relativePath);
          const path = buildPath(relativePath);

          files.push({
            id: generateId(relativePath),
            title,
            content: prefixedContent,
            url,
            path,
            category,
            section,
            subsection: subsection || undefined,
            description: description || undefined,
            tags,
            headings,
            lastModified: stat.mtime?.getTime() || Date.now(),
            docType: "markdown",
          });

          console.log(
            `Processed: ${relativePath} (${cleanedContent.length} chars)`,
          );
        } catch (error) {
          console.error(`Error processing ${entry.path}:`, error);
        }
      }
    } catch (error) {
      console.error(`Error walking directory ${dirPath}:`, error);
    }
  }

  return files;
}

/**
 * Generate statistics about the indexed content
 */
function generateStats(documents: OramaDocument[]): IndexStats {
  const stats: IndexStats = {
    totalDocuments: documents.length,
    totalCharacters: documents.reduce(
      (sum, doc) => sum + doc.content.length,
      0,
    ),
    averageDocumentLength: 0,
    categoryCounts: {} as Record<string, number>,
    sectionCounts: {} as Record<string, number>,
    documentsWithTags: documents.filter((doc) => doc.tags.length > 0).length,
    documentsWithDescriptions:
      documents.filter((doc) => doc.description).length,
    longestDocument: "",
    shortestDocument: "",
    apiDocuments:
      documents.filter((doc) => doc.docType === "api-reference").length,
    markdownDocuments:
      documents.filter((doc) => doc.docType === "markdown").length,
  };

  stats.averageDocumentLength = Math.round(
    stats.totalCharacters / stats.totalDocuments,
  );

  // Count by category
  documents.forEach((doc) => {
    stats.categoryCounts[doc.category] =
      (stats.categoryCounts[doc.category] || 0) + 1;
    const sectionKey = `${doc.category}/${doc.section}`;
    stats.sectionCounts[sectionKey] = (stats.sectionCounts[sectionKey] || 0) +
      1;
  });

  // Find longest and shortest documents
  let longest = documents[0];
  let shortest = documents[0];
  documents.forEach((doc) => {
    if (doc.content.length > longest.content.length) longest = doc;
    if (doc.content.length < shortest.content.length) shortest = doc;
  });
  stats.longestDocument = `${longest.title} (${longest.content.length} chars)`;
  stats.shortestDocument =
    `${shortest.title} (${shortest.content.length} chars)`;

  return stats;
}

/**
 * Main function to generate the comprehensive Orama index
 */
async function main(outputDir?: string) {
  console.log(
    "ðŸ” Generating comprehensive Orama search index for Deno documentation...\n",
  );

  // Process markdown files
  console.log("Processing markdown documentation...");
  const markdownDocs = await collectMarkdownFiles();
  console.log(`âœ… Collected ${markdownDocs.length} markdown documents\n`);

  // Process API reference documentation
  console.log("ðŸ”§ Processing API reference documentation...");
  const apiDocs = await processReferenceDocumentation();
  console.log(`âœ… Collected ${apiDocs.length} API reference documents\n`);

  // Combine all documents
  const allDocuments = [...markdownDocs, ...apiDocs];

  if (allDocuments.length === 0) {
    console.error("âŒ No documents found to index");
    Deno.exit(1);
  }

  // Generate statistics
  const stats = generateStats(allDocuments);
  console.log("Comprehensive Index Statistics:");
  console.log(`   Total documents: ${stats.totalDocuments}`);
  console.log(`   Markdown documents: ${stats.markdownDocuments}`);
  console.log(`   API reference documents: ${stats.apiDocuments}`);
  console.log(`   Total characters: ${stats.totalCharacters.toLocaleString()}`);
  console.log(
    `   Average document length: ${stats.averageDocumentLength} chars`,
  );
  console.log(`   Documents with tags: ${stats.documentsWithTags}`);
  console.log(
    `   Documents with descriptions: ${stats.documentsWithDescriptions}`,
  );

  // Use the specified output directory or default to the static directory
  const outDir = outputDir
    ? join(ROOT_DIR, outputDir)
    : join(ROOT_DIR, "static");

  try {
    await Deno.stat(outDir);
  } catch (error) {
    if (error instanceof Deno.errors.NotFound) {
      console.error(`âŒ The output directory ${outDir} does not exist`);
      Deno.exit(1);
    }
    throw error;
  }

  // Prepare the final index data
  const indexData = {
    metadata: {
      generatedAt: new Date().toISOString(),
      version: "2.0.0",
      baseUrl: BASE_URL,
      totalDocuments: allDocuments.length,
      includesApiReference: true,
      stats,
    },
    documents: allDocuments,
  };

  // Write the comprehensive index file
  const outputPath = join(outDir, "orama-index-full.json");
  await Deno.writeTextFile(outputPath, JSON.stringify(indexData, null, 2));

  console.log(`\nâœ… Generated comprehensive Orama index: ${outputPath}`);
  console.log(`File size: ${(await Deno.stat(outputPath)).size} bytes`);

  // Also generate a summary version
  const summaryDocuments = allDocuments.map((doc) => ({
    id: doc.id,
    title: doc.title,
    url: doc.url,
    category: doc.category,
    section: doc.section,
    docType: doc.docType,
    description: doc.description,
    tags: doc.tags.slice(0, 3), // Only first 3 tags
    contentPreview: doc.content.substring(0, 200) + "...", // First 200 chars
  }));

  const summaryIndexData = {
    metadata: indexData.metadata,
    documents: summaryDocuments,
  };

  const summaryOutputPath = join(outDir, "orama-index-summary.json");
  await Deno.writeTextFile(
    summaryOutputPath,
    JSON.stringify(summaryIndexData, null, 2),
  );

  console.log(`âœ… Generated summary index: ${summaryOutputPath}`);
  console.log(
    `File size: ${(await Deno.stat(summaryOutputPath)).size} bytes`,
  );

  console.log("\nNext steps:");
  console.log(
    "1. Upload the orama-index-full.json file to your Orama Cloud index",
  );
  console.log("2. Or use the Orama REST API to bulk insert the documents");
  console.log(
    "3. Configure your search client with the proper endpoint and API key",
  );
  console.log("4. Test searches for both documentation and API references");

  console.log("\nDone!");
}

// Run the main function
if (import.meta.main) {
  const args = Deno.args;
  const outputDir = args.length > 0 ? args[0] : undefined;
  main(outputDir);
}

// Export functions for use in other scripts
export { collectMarkdownFiles, generateStats, processReferenceDocumentation };
