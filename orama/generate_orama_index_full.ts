#!/usr/bin/env -S deno run --allow-read --allow-write
/**
 * Enhanced Orama Index Generator for Deno Documentation
 *
 * This script generates a comprehensive JSON file containing all documentation content,
 * including both markdown files and API reference documentation generated by reference_gen.
 *
 * It processes:
 * - Markdown documentation from runtime/, deploy/, examples/, etc. (using MarkdownIndexer)
 * - API reference documentation from reference_gen/gen/ (Deno, Web, Node APIs)
 *
 * Usage:
 *   deno task generate:orama:full          # Generate comprehensive index
 *   deno run -A generate_orama_index_full_refactored.ts _site  # Generate to _site directory
 */

import { walk } from "@std/fs";
import { fromFileUrl, join, relative } from "@std/path";
import { MarkdownIndexer } from "./indexing/MarkdownIndexer.ts";
import { FileSelector } from "./identification/FileSelector.ts";
import { IndexCollection } from "./indexing/IndexCollection.ts";
import { OramaJsonOutput } from "./outputs/OramaJsonOutput.ts";
import type { OramaDocument } from "./types.ts";

const BASE_URL = "https://docs.deno.com";
const ROOT_DIR = fromFileUrl(new URL("../", import.meta.url));

// Reference documentation files for API documentation
const REFERENCE_FILES = [
  {
    path: "reference_gen/gen/deno.json",
    apiType: "deno",
    baseUrl: "/api/deno",
  },
  { path: "reference_gen/gen/web.json", apiType: "web", baseUrl: "/api/web" },
  {
    path: "reference_gen/gen/node.json",
    apiType: "node",
    baseUrl: "/api/node",
  },
];

interface OramaFullDocument extends OramaDocument {
  docType: "markdown" | "api-reference";
  packageName?: string;
}

interface IndexMetadata {
  generatedAt: string;
  version: string;
  baseUrl: string;
  totalDocuments: number;
  includesApiReference: boolean;
  stats: {
    totalDocuments: number;
    totalCharacters: number;
    averageDocumentLength: number;
    categoryCounts: Record<string, number>;
    sectionCounts: Record<string, number>;
    documentsWithTags: number;
    documentsWithDescriptions: number;
    longestDocument: string;
    shortestDocument: string;
    apiDocuments: number;
    markdownDocuments: number;
  };
}

/**
 * Generate a unique ID for API documents
 */
function generateApiId(relativePath: string, apiType: string): string {
  const basePath = `api-${apiType}-${relativePath}`;
  return basePath
    .replace(/\.(md|mdx|json)$/, "")
    .replace(/[\/\\]/g, "-")
    .replace(/[^a-zA-Z0-9-_~.]/g, "")
    .toLowerCase();
}

/**
 * Build URL for API documents
 */
function buildApiUrl(relativePath: string, baseUrl: string): string {
  return `${BASE_URL}${baseUrl}/${relativePath}`;
}

/**
 * Build path for API documents
 */
function buildApiPath(relativePath: string, baseUrl: string): string {
  return `${baseUrl}/${relativePath}`;
}

/**
 * Process a SymbolPageCtx entry from the reference documentation
 */
function processSymbolPageContext(
  symbolPath: string,
  data: Record<string, unknown>,
  apiType: string,
  baseUrl: string,
): OramaFullDocument[] {
  const documents: OramaFullDocument[] = [];
  
  // Extract symbol group context
  const symbolGroupCtx = data.symbol_group_ctx as Record<string, unknown>;
  if (!symbolGroupCtx || typeof symbolGroupCtx.name !== "string") {
    return documents;
  }

  const symbolName = symbolGroupCtx.name;
  
  // Extract HTML head context for title
  const htmlHeadCtx = data.html_head_ctx as Record<string, unknown>;
  const title = htmlHeadCtx?.title as string || symbolName;

  // Process symbols array
  const symbols = symbolGroupCtx.symbols as Array<Record<string, unknown>>;
  if (!Array.isArray(symbols) || symbols.length === 0) {
    return documents;
  }

  // Create content from the symbol documentation
  const contentParts: string[] = [];
  contentParts.push(symbolName); // Always include name first

  for (const symbol of symbols) {
    const symbolContent = symbol.content as Array<Record<string, unknown>>;
    if (Array.isArray(symbolContent)) {
      for (const content of symbolContent) {
        if (content.kind === "other" && content.value) {
          const value = content.value as Record<string, unknown>;
          if (typeof value.docs === "string") {
            // Extract text from HTML docs
            const docText = value.docs
              .replace(/<[^>]*>/g, '') // Remove HTML tags
              .replace(/&[^;]+;/g, ' ') // Replace HTML entities
              .trim();
            if (docText) {
              contentParts.push(docText);
            }
          }
        }
      }
    }

    // Extract kind information
    const kind = symbol.kind as Record<string, unknown>;
    if (kind?.kind && typeof kind.kind === "string") {
      contentParts.push(`Type: ${kind.kind}`);
    }
  }

  const content = contentParts.join("\n\n").trim();

  // Skip if content is too short
  if (content.length < 10) {
    return documents;
  }

  // Build the correct URL from the symbolPath
  // Convert "./~/Deno.ServeHandlerInfo.json" to "/api/deno/~/Deno.ServeHandlerInfo"
  let cleanPath = symbolPath;
  if (cleanPath.startsWith("./")) {
    cleanPath = cleanPath.substring(2); // Remove "./"
  }
  if (cleanPath.endsWith(".json")) {
    cleanPath = cleanPath.substring(0, cleanPath.length - 5); // Remove ".json"
  }
  
  const url = `${BASE_URL}${baseUrl}/${cleanPath}`;
  const path = `${baseUrl}/${cleanPath}`;

  // Extract package name from symbol name
  const parts = symbolName.split('.');
  const packageName = parts.length > 1 ? parts[0] : "general";
  const kind = symbols[0]?.kind as Record<string, unknown>;
  const kindStr = kind?.kind as string || "unknown";

  documents.push({
    id: generateApiId(symbolPath, apiType),
    title,
    content,
    url,
    path,
    category: apiType,
    section: packageName || "general",
    subsection: kindStr,
    description: undefined,
    tags: [apiType, kindStr, packageName].filter(Boolean),
    headings: [],
    lastModified: Date.now(),
    docType: "api-reference",
    packageName,
  });

  return documents;
}

/**
 * Process a single API symbol from reference documentation
 */
function processApiSymbol(
  symbolPath: string,
  symbolData: unknown,
  apiType: string,
  baseUrl: string,
  packageName: string,
): OramaFullDocument[] {
  const documents: OramaFullDocument[] = [];

  if (typeof symbolData !== "object" || symbolData === null) {
    return documents;
  }

  const data = symbolData as Record<string, unknown>;

  // Handle the structured JSON format from reference_gen
  if (data.kind === "SymbolPageCtx" && data.symbol_group_ctx) {
    return processSymbolPageContext(symbolPath, data, apiType, baseUrl);
  }

  // Fallback to old format - Skip if no name
  if (typeof data.name !== "string") {
    return documents;
  }

  const name = data.name;
  const kind = typeof data.kind === "string" ? data.kind : "unknown";

  // Create content from available fields
  const contentParts: string[] = [];
  contentParts.push(name); // Always include name first

  if (typeof data.jsDoc === "object" && data.jsDoc !== null) {
    const jsDoc = data.jsDoc as Record<string, unknown>;
    if (typeof jsDoc.doc === "string" && jsDoc.doc.trim()) {
      contentParts.push(jsDoc.doc.trim());
    }
  }

  // For functions, include parameters and return info
  if (data.functionDef && typeof data.functionDef === "object") {
    const funcDef = data.functionDef as Record<string, unknown>;
    if (Array.isArray(funcDef.params)) {
      const paramNames = funcDef.params
        .map((p: unknown) => {
          if (typeof p === "object" && p !== null) {
            const param = p as Record<string, unknown>;
            return typeof param.name === "string" ? param.name : "";
          }
          return "";
        })
        .filter(Boolean);
      if (paramNames.length > 0) {
        contentParts.push(`Parameters: ${paramNames.join(", ")}`);
      }
    }
  }

  // For classes, include method names
  if (data.classDef && typeof data.classDef === "object") {
    const classDef = data.classDef as Record<string, unknown>;
    if (Array.isArray(classDef.methods)) {
      const methodNames = classDef.methods
        .map((m: unknown) => {
          if (typeof m === "object" && m !== null) {
            const method = m as Record<string, unknown>;
            return typeof method.name === "string" ? method.name : "";
          }
          return "";
        })
        .filter(Boolean);
      if (methodNames.length > 0) {
        contentParts.push(`Methods: ${methodNames.join(", ")}`);
      }
    }
  }

  const content = contentParts.join("\n\n").trim();

  // Skip if content is too short
  if (content.length < 10) {
    return documents;
  }

  // Create the document
  const cleanPath = symbolPath.replace(/\./g, "/");
  const url = buildApiUrl(cleanPath, baseUrl);
  const path = buildApiPath(cleanPath, baseUrl);

  documents.push({
    id: generateApiId(symbolPath, apiType),
    title: `${packageName}.${name}`,
    content,
    url,
    path,
    category: apiType,
    section: packageName || "general",
    subsection: kind,
    description: undefined,
    tags: [apiType, kind, packageName].filter(Boolean),
    headings: [],
    lastModified: Date.now(),
    docType: "api-reference",
    packageName,
  });

  return documents;
}

/**
 * Process API reference documentation
 */
async function processApiReference(): Promise<OramaFullDocument[]> {
  console.log("\n🔧 Processing API reference documentation...");
  const apiDocs: OramaFullDocument[] = [];

  for (const refFile of REFERENCE_FILES) {
    const fullPath = join(ROOT_DIR, refFile.path);

    try {
      await Deno.stat(fullPath);
      console.log(`Processing ${refFile.apiType} API documentation...`);

      const content = await Deno.readTextFile(fullPath);
      const data = JSON.parse(content);

      let processedCount = 0;
      let skippedCount = 0;

      // Process each entry in the reference JSON
      for (const [entryPath, entryData] of Object.entries(data)) {
        // Skip index and all_symbols entries
        if (entryPath === "./index.json" || entryPath === "./all_symbols.json") {
          continue;
        }
        
        const docs = processApiSymbol(
          entryPath,
          entryData,
          refFile.apiType,
          refFile.baseUrl,
          "Deno", // Default package name for now
        );

        if (docs.length > 0) {
          apiDocs.push(...docs);
          processedCount++;
        } else {
          skippedCount++;
        }
      }

      console.log(
        `  Processed ${processedCount} ${refFile.apiType} API symbols (skipped ${skippedCount})`,
      );
    } catch (error) {
      console.warn(`Reference file not found or invalid: ${fullPath}`);
      console.warn(`Error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  return apiDocs;
}

/**
 * Process markdown documentation using the existing MarkdownIndexer
 */
async function processMarkdownDocuments(): Promise<OramaFullDocument[]> {
  console.log("Processing markdown documentation...");
  
  const fileSelector = new FileSelector();
  const markdownIndexer = new MarkdownIndexer();
  const documents: OramaFullDocument[] = [];

  // Use the existing file selection and indexing logic
  for await (const file of fileSelector.selectInputFiles("./")) {
    if (markdownIndexer.isValidIndexer(file)) {
      const doc = await markdownIndexer.tryIndex(file);
      if (doc) {
        // Convert to full document format
        const fullDoc: OramaFullDocument = {
          ...doc,
          docType: "markdown",
        };
        documents.push(fullDoc);
      }
    }
  }

  return documents;
}

/**
 * Calculate statistics for the generated index
 */
function calculateStats(documents: OramaFullDocument[]): IndexMetadata["stats"] {
  const totalCharacters = documents.reduce((sum, doc) => sum + doc.content.length, 0);
  const averageDocumentLength = Math.round(totalCharacters / documents.length);

  const categoryCounts: Record<string, number> = {};
  const sectionCounts: Record<string, number> = {};
  
  let documentsWithTags = 0;
  let documentsWithDescriptions = 0;
  let longestDoc = { title: "", length: 0 };
  let shortestDoc = { title: "", length: Infinity };
  let apiDocuments = 0;
  let markdownDocuments = 0;

  for (const doc of documents) {
    // Category counts
    categoryCounts[doc.category] = (categoryCounts[doc.category] || 0) + 1;
    
    // Section counts
    const sectionKey = `${doc.category}/${doc.section}`;
    sectionCounts[sectionKey] = (sectionCounts[sectionKey] || 0) + 1;

    // Other stats
    if (doc.tags && doc.tags.length > 0) documentsWithTags++;
    if (doc.description) documentsWithDescriptions++;
    if (doc.docType === "api-reference") apiDocuments++;
    if (doc.docType === "markdown") markdownDocuments++;

    // Longest/shortest
    if (doc.content.length > longestDoc.length) {
      longestDoc = { title: doc.title, length: doc.content.length };
    }
    if (doc.content.length < shortestDoc.length) {
      shortestDoc = { title: doc.title, length: doc.content.length };
    }
  }

  return {
    totalDocuments: documents.length,
    totalCharacters,
    averageDocumentLength,
    categoryCounts,
    sectionCounts,
    documentsWithTags,
    documentsWithDescriptions,
    longestDocument: `${longestDoc.title} (${longestDoc.length.toLocaleString()} chars)`,
    shortestDocument: `${shortestDoc.title} (${shortestDoc.length} chars)`,
    apiDocuments,
    markdownDocuments,
  };
}

/**
 * Main function
 */
async function main() {
  console.log("🔍 Generating comprehensive Orama search index for Deno documentation...\n");

  const outputDir = Deno.args.length > 0 ? Deno.args[0] : undefined;

  // Process markdown documents using the existing indexer
  const markdownDocs = await processMarkdownDocuments();
  console.log(`✅ Collected ${markdownDocs.length} markdown documents`);

  // Process API reference documentation
  const apiDocs = await processApiReference();
  console.log(`✅ Collected ${apiDocs.length} API reference documents`);

  // Combine all documents
  const allDocuments = [...markdownDocs, ...apiDocs];

  // Calculate statistics
  const stats = calculateStats(allDocuments);

  console.log("\nComprehensive Index Statistics:");
  console.log(`   Total documents: ${stats.totalDocuments.toLocaleString()}`);
  console.log(`   Markdown documents: ${stats.markdownDocuments.toLocaleString()}`);
  console.log(`   API reference documents: ${stats.apiDocuments.toLocaleString()}`);
  console.log(`   Total characters: ${stats.totalCharacters.toLocaleString()}`);
  console.log(`   Average document length: ${stats.averageDocumentLength} chars`);
  console.log(`   Documents with tags: ${stats.documentsWithTags.toLocaleString()}`);
  console.log(`   Documents with descriptions: ${stats.documentsWithDescriptions.toLocaleString()}`);

  // Create metadata
  const metadata: IndexMetadata = {
    generatedAt: new Date().toISOString(),
    version: "2.0.0",
    baseUrl: BASE_URL,
    totalDocuments: allDocuments.length,
    includesApiReference: apiDocs.length > 0,
    stats,
  };

  // Generate outputs
  const outputPath = outputDir ? join(outputDir, "orama-index-full.json") : "static/orama-index-full.json";
  const summaryPath = outputDir ? join(outputDir, "orama-index-summary.json") : "static/orama-index-summary.json";

  // Write full index
  const fullIndex = {
    metadata,
    data: allDocuments,
  };

  await Deno.writeTextFile(outputPath, JSON.stringify(fullIndex, null, 0));
  console.log(`✅ Generated comprehensive Orama index: ${outputPath}`);

  const fullIndexStat = await Deno.stat(outputPath);
  console.log(`File size: ${fullIndexStat.size.toLocaleString()} bytes`);

  // Write summary index (titles and URLs only for lighter searches)
  const summaryIndex = {
    metadata,
    data: allDocuments.map((doc) => ({
      id: doc.id,
      title: doc.title,
      url: doc.url,
      path: doc.path,
      category: doc.category,
      section: doc.section,
      subsection: doc.subsection,
      description: doc.description,
      tags: doc.tags,
      docType: doc.docType,
    })),
  };

  await Deno.writeTextFile(summaryPath, JSON.stringify(summaryIndex, null, 0));
  console.log(`✅ Generated summary index: ${summaryPath}`);

  const summaryIndexStat = await Deno.stat(summaryPath);
  console.log(`File size: ${summaryIndexStat.size.toLocaleString()} bytes`);

  console.log("\nNext steps:");
  console.log("1. Upload the orama-index-full.json file to your Orama Cloud index");
  console.log("2. Or use the Orama REST API to bulk insert the documents");
  console.log("3. Configure your search client with the proper endpoint and API key");
  console.log("4. Test searches for both documentation and API references");

  console.log("\nDone!");
}

if (import.meta.main) {
  await main();
}
