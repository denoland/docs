#!/usr/bin/env -S deno run -A
/**
 * Generates Standard Library package documentation pages under
 * `runtime/reference/std/`.
 *
 * Data sources:
 *  - List of packages: https://jsr.io/api/scopes/std/packages
 *  - Package docs HTML (overview): https://jsr.io/api/scopes/std/packages/<name>/versions/<version>/docs
 *    We extract the first <div class="markdown">...</div> inner HTML and convert
 *    to markdown (JSR already returns markdown-rendered HTML; we keep as HTML fragment).
 *
 * Each generated page:
 *  frontmatter: title, description (first paragraph text), jsr, pkg, version, autogenerated flag
 *  body: (1) Overview fragment (HTML) (2) Optional override markdown appended
 *        from `runtime/reference/std/_overrides/<pkg>.md` (if present)
 *
 * Additionally generates an index page `runtime/reference/std/index.md` listing
 * all discovered packages with short description from the API list.
 *
 * All pages are generated in place. To add persistent custom content, use
 * the <!-- custom:start --> ... <!-- custom:end --> block or an override file.
 */

// Using JSR std modules (available via deno.json imports mapping)
import { ensureDir } from "@std/fs";
import { fromFileUrl, join } from "@std/path";

interface PackageSummary {
  name: string;
  latestVersion: string; // derived
  description?: string;
}

interface PackageApiEntry {
  scope: string; // "std"
  name: string; // package name without @std/
  description?: string;
  versions?: { tag: string; createdAt: string }[]; // Not currently returned in list endpoint
  latestVersion: string; // present in list response
}

// Derive repo root (the workspace 'docs' directory). Script lives in <repo>/scripts/, so one level up.
const REPO_ROOT = fromFileUrl(new URL("../", import.meta.url));
const STD_ROOT = join(REPO_ROOT, "runtime", "reference", "std");
const GENERATED_DIR = STD_ROOT; // Emit pages directly for clean /std/<pkg>/ paths
const OVERRIDES_DIR = join(STD_ROOT, "_overrides");

async function fetchJson<T>(url: string): Promise<T> {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Fetch failed ${url} ${res.status}`);
  return await res.json() as T;
}

async function fetchText(url: string): Promise<string> {
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Fetch failed ${url} ${res.status}`);
  return await res.text();
}

function extractFirstMarkdownDiv(html: string): string | null {
  // More permissive: allow attributes ordering and additional classes.
  const match = html.match(
    /<div[^>]*class=\"markdown\"[^>]*>([\s\S]*?)<\/div>/,
  );
  if (!match) return null;
  const fragment = match[1].trim();
  return fragment;
}

function deriveTitle(pkg: string): string {
  // e.g., "assert" -> "@std/assert"
  switch (pkg) {
    case "assert":
      return "Standard Assertions (@std/assert)"; // keep consistent with handcrafted page
    default:
      return `@std/${pkg}`;
  }
}

async function generatePackagePage(pkg: PackageSummary) {
  const { name, latestVersion } = pkg;
  // (Legacy skip logic removed; we always regenerate the page.)

  const docsUrl =
    `https://jsr.io/api/scopes/std/packages/${name}/versions/${latestVersion}/docs`;
  let overviewHtml: string | null = null;
  try {
    // The docs endpoint returns JSON with keys: kind, version, css, comrakCss, script, breadcrumbs, toc, main, etc.
    const raw = await fetchText(docsUrl);
    let parsed: Record<string, unknown> | null = null;
    try {
      parsed = JSON.parse(raw);
    } catch (_) {
      // Not JSON (unexpected) fallback treat as HTML
    }
    if (
      parsed && typeof parsed === "object" && typeof parsed["main"] === "string"
    ) {
      const mainHtml = String(parsed["main"]);
      // In main section look for first markdown div.
      overviewHtml = extractFirstMarkdownDiv(mainHtml) ?? null;
      if (!overviewHtml) {
        // Some packages may have the overview inside toc usage content; fallback search entire raw
        overviewHtml = extractFirstMarkdownDiv(raw) ?? null;
      }
    } else {
      // Fallback to legacy pattern
      overviewHtml = extractFirstMarkdownDiv(raw);
    }
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    console.warn(`‚ö†Ô∏è Failed to fetch docs for ${name}: ${msg}`);
  }

  // Read override markdown if present
  const overridePath = join(OVERRIDES_DIR, `${name}.md`);
  let overrideContent = "";
  try {
    overrideContent = await Deno.readTextFile(overridePath);
  } catch (_) {
    // ignore
  }

  // (Legacy handcrafted append removed.)

  if (!overviewHtml) {
    console.warn(`Skipping ${name} (no overview HTML)`);
    return;
  }

  // Derive a plain text first paragraph from overview for fallback only.
  const overviewFirstParagraph = overviewHtml
    .replace(/<[^>]+>/g, "\n")
    .split(/\n+/)
    .map((l) => l.trim())
    .filter(Boolean)[0] ?? "";

  // Prefer the list API description for stability detection and description content.
  const sourceDescription = (pkg as PackageSummary).description ||
    overviewFirstParagraph;
  let stability: "unstable" | "internal" | "stable" = "stable";
  let normalizedDesc = sourceDescription;
  if (/^UNSTABLE:/i.test(sourceDescription)) {
    stability = "unstable";
    normalizedDesc = sourceDescription.replace(/^UNSTABLE:\s*/i, "");
  } else if (/^INTERNAL:/i.test(sourceDescription)) {
    stability = "internal";
    normalizedDesc = sourceDescription.replace(/^INTERNAL:\s*/i, "");
  }

  const frontmatter = [
    "---",
    `title: \"${deriveTitle(name)}\"`,
    `description: \"${normalizedDesc.replaceAll(/"/g, '\\"').slice(0, 240)}\"`,
    `jsr: jsr:@std/${name}`,
    `pkg: ${name}`,
    `version: ${latestVersion}`,
    `generated: true`,
    `stability: ${stability}`,
    "---",
    "",
  ].join("\n");

  // Attempt to extract any existing custom block from prior file (between markers)
  const existingPath = join(GENERATED_DIR, `${name}.md`);
  let preservedCustom = "";
  try {
    const prev = await Deno.readTextFile(existingPath);
    const m = prev.match(/<!-- custom:start -->([\s\S]*?)<!-- custom:end -->/);
    if (m) {
      preservedCustom = m[1].trim();
    }
  } catch (_) {
    // no previous file
  }

  let body = frontmatter +
    `<!-- Autogenerated from JSR docs. Do not edit directly. -->\n\n`;
  if (stability === "unstable") {
    body +=
      `> ‚ö†Ô∏è **Unstable**: This @std package is experimental and its API may change without a major version bump.\n\n`;
  } else if (stability === "internal") {
    body +=
      `> ‚õî **Internal**: This @std package is for internal use and not intended for public consumption. APIs may change or be removed.\n\n`;
  }
  body += `## Overview\n\n`;
  body += overviewHtml + "\n"; // keep HTML fragment
  if (overrideContent) {
    body += `\n## Additional Examples\n\n${overrideContent}\n`;
  }

  // Insert custom block placeholder or preserved content at end
  if (preservedCustom) {
    body +=
      `\n<!-- custom:start -->\n${preservedCustom}\n<!-- custom:end -->\n`;
  } else {
    body +=
      `\n<!-- custom:start -->\n<!-- Add persistent custom content below. This section is preserved across generations. -->\n\n<!-- custom:end -->\n`;
  }

  await ensureDir(GENERATED_DIR);
  const outPath = join(GENERATED_DIR, `${name}.md`);
  await Deno.writeTextFile(outPath, body);
  console.log(`‚úÖ Generated ${outPath}`);
}

async function generateIndex(packages: PackageSummary[]) {
  const indexPath = join(STD_ROOT, "index.md");
  const rows: string[] = [];
  for (const p of packages) {
    const link = `./${p.name}/`; // folder-style link (Lume will map file.md -> /file/)
    rows.push(`- [@std/${p.name}](${link}) ‚Äì ${p.description ?? ""}`);
  }
  const content = [
    "---",
    'title: "Deno Standard Library (@std)"',
    'description: "Overview and guides for the modular Deno standard library packages on JSR."',
    "---",
    "",
    "The Deno standard library is published as a set of modular JSR packages under the `@std` scope.",
    "\n## Packages\n",
    rows.join("\n"),
    "",
    "> This index and the individual package overview sections are generated. Add extra examples by creating files in `_overrides/<package>.md`.",
  ].join("\n");

  await Deno.writeTextFile(indexPath, content);
  console.log(`üóÇÔ∏è  Wrote index ${indexPath}`);
}

async function main() {
  console.log("Fetching std package list...");
  const listResponse = await fetchJson<{ items: PackageApiEntry[] }>(
    "https://jsr.io/api/scopes/std/packages",
  );
  const list = listResponse.items;
  const summaries: PackageSummary[] = list.map((p) => ({
    name: p.name,
    description: p.description,
    latestVersion: p.latestVersion.replace(/^v/, ""),
  }));

  // Generate each package page sequentially (can parallelize later)
  for (const pkg of summaries) {
    await generatePackagePage(pkg);
  }
  await generateIndex(summaries);
}

if (import.meta.main) {
  await main();
}
